// ---------------------------------------------
//           This file is part of
//      _  _   __    _   _    __    __
//     ( \/ ) /__\  ( )_( )  /__\  (  )
//      \  / /(__)\  ) _ (  /(__)\  )(__
//      (__)(__)(__)(_) (_)(__)(__)(____)
//
//     Yet Another HW Abstraction Library
//      Copyright (C) Andreas Terstegge
//      BSD Licensed (see file LICENSE)
//
// ---------------------------------------------
//
// Small program to convert any file into a C/C++ struct
//
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>
#include <libgen.h>

using namespace std;

int main(int argc, char *argv[]) {

    // Check command line parameter
    if (argc != 2) {
        cerr << "Usage: " << argv[0] << " <file>" << endl << endl;
        exit(1);
    }

    // Process the file name
    string infile = argv[1];
    size_t dot = infile.find_last_of('.');
    string name_we;
    if (dot != string::npos) {
        name_we = infile.substr(0, dot);
    } else {
        name_we = infile;
    }
    string outfile = name_we + ".cpp";
    string base    = basename( (char*)name_we.c_str() );
    // Dashes are not valid in variable names, so replace them
    std::replace(base.begin(), base.end(), '-', '_');

    // Open in and out files
    ifstream ifs(infile.c_str(), ios::binary | ios::in);
    ofstream ofs(outfile.c_str(), ios::binary | ios::out);

    // Get the input file size
    streampos begin, end;
    begin = ifs.tellg();
    ifs.seekg(0, ios_base::end);
    end = ifs.tellg();
    ifs.seekg(0, ios_base::beg);
    size_t filesize = end - begin;

    // Write outfile
    ofs << "//" << endl;
    ofs << "// This file was generated by file2cpp, a small" << endl;
    ofs << "// program to convert any binary or text file" << endl;
    ofs << "// into a C/C++ struct of unsigned characters." << endl;
    ofs << "//" << endl;
    ofs << "//  Source file was: " << infile << " (size: " << filesize
        << " bytes)" << endl;
    ofs << "//" << endl << endl;
    ofs << "unsigned char " << base << "[" << filesize << "] = {" << endl;
    size_t count = 0;
    while (true) {
        char c;
        ifs.read(&c, 1);
        if (ifs.fail())  break;
        unsigned short s = c;
        s &= 0xff;
        ofs << "0x" << hex << setw(2) << setfill('0') << s;
        count++;
        if (count != filesize) ofs << ", ";
        if ((count % 10) == 0) ofs << endl;
    }
    ofs << endl << "};" << endl;

    // Close all files
    ifs.close();
    ofs.close();
    return 0;
}
