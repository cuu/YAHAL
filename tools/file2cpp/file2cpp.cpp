// ---------------------------------------------
//           This file is part of
//      _  _   __    _   _    __    __
//     ( \/ ) /__\  ( )_( )  /__\  (  )
//      \  / /(__)\  ) _ (  /(__)\  )(__
//      (__)(__)(__)(_) (_)(__)(__)(____)
//
//     Yet Another HW Abstraction Library
//      Copyright (C) Andreas Terstegge
//      BSD Licensed (see file LICENSE)
//
// ---------------------------------------------
//
// Small program to convert any file into a C/C++ struct
//
#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include <algorithm>
#include <cstdint>
#include <cstdlib>
#include <getopt.h>
#include <libgen.h>

using namespace std;

void usage() {
    cout << "Usage: file2cpp [-o outfile] file"<< endl;
    cout << endl;
    cout << "-o outfile  : The output filename. Default is file.cpp" << endl;
    cout << "file        : A valid file" << endl;
    exit(1);
}

int main(int argc, char *argv[]) {
    // Process the command line arguments
    string infile;
    string outfile;
    int opt;
    while ((opt = getopt(argc, argv, ":o:")) != -1) {
        switch (opt) {
            case 'o': {
                outfile = optarg;
                break;
            }
            case ':': {
                cerr << "Option needs a value!" << endl;
                usage();
                break;
            }
            case '?': {
                cerr << "Unknown option '" << (char)optopt << "'" << endl;
                usage();
                break;
            }
        }
    }
    if (optind == (argc-1)) {
        infile = argv[optind];
    } else {
        cerr << "No or too many filenames given!" << endl;
        usage();
    }

    // Process the file name
    size_t dot = infile.find_last_of('.');
    string name_we;
    if (dot != string::npos) {
        name_we = infile.substr(0, dot);
    } else {
        name_we = infile;
    }
    if (outfile.size()==0) {
        // Set the default output name
        outfile = name_we + ".cpp";
    }
    string base = basename( (char*)name_we.c_str() );
    // Dashes are not valid in variable names, so replace them
    std::replace(base.begin(), base.end(), '-', '_');

    // Open in and out files
    ifstream ifs(infile.c_str(), ios::binary | ios::in);
    ofstream ofs(outfile.c_str(), ios::binary | ios::out);

    if (!ifs) {
        cerr << "Error: Could not open input file " << infile << endl;
        exit(1);
    }
    if (!ofs) {
        cerr << "Error: Could not open output file " << outfile << endl;
        exit(1);
    }
    
    // Get the input file size
    streampos begin, end;
    begin = ifs.tellg();
    ifs.seekg(0, ios_base::end);
    end = ifs.tellg();
    ifs.seekg(0, ios_base::beg);
    size_t filesize = end - begin;

    // Write outfile
    ofs << "//" << endl;
    ofs << "// This file was generated by file2cpp, a small" << endl;
    ofs << "// program to convert any binary or text file" << endl;
    ofs << "// into a C/C++ struct of unsigned characters." << endl;
    ofs << "//" << endl;
    ofs << "//  Source file was: " << infile << " (size: " << filesize
        << " bytes)" << endl;
    ofs << "//" << endl << endl;
    ofs << "#include <cstdint>" << endl;
    ofs << endl;
    ofs << "extern const uint8_t " << base << "[" << filesize << "] = {" << endl;
    size_t count = 0;
    while (true) {
        char c;
        ifs.read(&c, 1);
        if (ifs.fail())  break;
        unsigned short s = c;
        s &= 0xff;
        ofs << "0x" << hex << setw(2) << setfill('0') << s;
        count++;
        if (count != filesize) ofs << ", ";
        if ((count % 10) == 0) ofs << endl;
    }
    ofs << endl << "};" << endl;

    // Close all files
    ifs.close();
    ofs.close();
    return 0;
}
